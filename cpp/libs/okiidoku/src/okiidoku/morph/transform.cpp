// SPDX-FileCopyrightText: 2020 David Fong
// SPDX-License-Identifier: AGPL-3.0-or-later
#include <okiidoku/morph/transform.hpp>

#include <okiidoku/grid.hpp>
#include <okiidoku/order.hpp>

#include <utility> // swap

namespace okiidoku::mono {

	template<Order O> requires(is_order_compiled(O))
	void Transformation<O>::apply_from_to(const Grid<O>& src_grid, Grid<O>& dest_grid) const noexcept {
		OKIIDOKU_CONTRACT_USE(&src_grid != &dest_grid);
		// TODO experimental optimization: linearize row_map and col_map, and copy sym_map to an extended version with map[O2] = O2
		for (const auto src_row : T::O2) {
		for (const auto src_col : T::O2) {
			auto dest_row { row_map[src_row/T::O1][src_row%T::O1] };
			auto dest_col { col_map[src_col/T::O1][src_col%T::O1] };
			if (post_transpose) { std::swap(dest_row, dest_col); }
			const auto src_sym {src_grid.at(src_row, src_col)};
			dest_grid.at(dest_row, dest_col) = (src_sym == T::O2)
				? grid_val_t<O>{T::O2}
				: grid_val_t<O>{sym_map[src_sym]};
		}}
	}


	template<Order O> requires(is_order_compiled(O))
	void Transformation<O>::apply_in_place(Grid<O>& grid) const noexcept {
		const Grid<O> copy {grid};
		apply_from_to(copy, grid);
	}


	template<Order O> requires(is_order_compiled(O))
	Transformation<O> Transformation<O>::inverted() const noexcept {
		OKIIDOKU_DEFER_INIT Transformation<O> inv;
		for (const auto i : T::O2) {
			inv.sym_map[sym_map[i]] = static_cast<to_t>(i);
		}
		for (const auto i : T::O2) {
			const auto row_inv {row_map[i/T::O1][i%T::O1]};
			const auto col_inv {col_map[i/T::O1][i%T::O1]};
			inv.row_map[row_inv/T::O1][row_inv%T::O1] = static_cast<to_t>(i);
			inv.col_map[col_inv/T::O1][col_inv%T::O1] = static_cast<to_t>(i);
		}
		if (post_transpose) {
			// do the equivalent of a pre_transpose
			std::swap(inv.row_map, inv.col_map);
			inv.post_transpose = true;
		}
		return inv;
	}


	#define OKIIDOKU_FOREACH_O_EMIT(O_) \
		template struct Transformation<O_>;
	OKIIDOKU_FOREACH_O_DO_EMIT
	#undef OKIIDOKU_FOREACH_O_EMIT
}


namespace okiidoku::visitor {

	void Transformation::apply_from_to(const Grid& vis_src, Grid& vis_dest) const noexcept {
		if (this->get_order() != vis_src.get_order()) {
			return;
		}
		if (vis_src.get_order() != vis_dest.get_order()) {
			vis_dest.get_underlying_variant() = vis_src.get_underlying_variant(); // lazy-coding way to implement order change.
		}
		/* Note: The code generated by GCC for visit tables gets larger as
		the number of dimensions increases. Using macros like this to have
		"one-dimensional tables" shrank shared library's release build size
		from 388kB to 291kB, and with strip --string-unneeded from 232kB to
		220kB. Not a big difference, but we might as well. */
		switch (this->get_order()) {
		#define OKIIDOKU_FOREACH_O_EMIT(O_) \
		case O_: return this->unchecked_get_mono_exact<O_>().apply_from_to( \
			vis_src.unchecked_get_mono_exact<O_>(), vis_dest.unchecked_get_mono_exact<O_>() \
		);
		OKIIDOKU_FOREACH_O_DO_EMIT
		#undef OKIIDOKU_FOREACH_O_EMIT
		default: OKIIDOKU_UNREACHABLE;
		}
	}


	void Transformation::apply_in_place(Grid& vis_grid) const noexcept {
		if (this->get_order() != vis_grid.get_order()) {
			return;
		}
		switch (this->get_order()) {
		#define OKIIDOKU_FOREACH_O_EMIT(O_) \
		case O_: return this->unchecked_get_mono_exact<O_>().apply_in_place( \
			vis_grid.unchecked_get_mono_exact<O_>() \
		);
		OKIIDOKU_FOREACH_O_DO_EMIT
		#undef OKIIDOKU_FOREACH_O_EMIT
		default: OKIIDOKU_UNREACHABLE;
		}
	}


	Transformation Transformation::inverted() const noexcept {
		switch (this->get_order()) {
		#define OKIIDOKU_FOREACH_O_EMIT(O_) \
		case O_: return static_cast<Transformation>(this->unchecked_get_mono_exact<O_>().inverted());
		OKIIDOKU_FOREACH_O_DO_EMIT
		#undef OKIIDOKU_FOREACH_O_EMIT
		default: OKIIDOKU_UNREACHABLE;
		}
	}
}